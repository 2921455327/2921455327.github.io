{"posts":[{"title":"手写JavaScript的call，apply函数","content":"apply和call函数的使用和区别 转换调用函数this的指向，将调用者的this指向传入的对象 在只传入this指向的对象而不传参的情况下,apply和call使用基本一致 如果不传入对象，默认传入的对象为window对象 //call的使用 function name() { //此时this指向call函数传入的对象 console.log(this); } let dog = { name: &quot;旺财&quot;, }; name.call(dog);//{ name: '旺财' } //apply的使用 function name() { //此时this指向apply函数传入的对象 console.log(this); } let dog = { name: &quot;旺财&quot;, }; name.apply(dog);//{ name: '旺财' } apply,call还可以给调用函数传参，apply传入的是一个数组形式，call传入的是单个并列的参数形式 function name(age1,age2) { console.log('我是'+this.name+',我今年'+age1+'岁了'+',我明年'+age2+'岁了'); } let dog = { name: &quot;旺财&quot;, }; //call name.call(dog,12,13);//我是旺财,我今年12岁了,我明年13岁了 //apply name.apply(dog,[12,13])//我是旺财,我今年12岁了,我明年13岁了 手写call函数 Function.prototype._call = function(obj,...args){ obj = obj || window //创建符号对象 const fn = Symbol(); //此处的this指向调用call的函数，相当于给新创建的对象加了一个属性，属性值为调用call的函数，此时函数的this指向已经指向了这个对象 obj[fn] = this //传参 let res = obj[fn](...args) //解除this的引用，避免一些效率上的问题 delete obj[fn] return res } //测试 function name(age1,age2) { console.log('我是'+this.name+',我今年'+age1+'岁了'+',我明年'+age2+'岁了'); } let dog = { name: &quot;旺财&quot;, }; name._call(dog,12,13);//我是旺财,我今年12岁了,我明年13岁了 手写apply函数 apply和call函数只在传入参数时不太一样，其他部分完全一致 // 因为apply传入的是一个数组，所以要用args接收这个数组 Function.prototype._apply = function(obj,args){ obj = obj || window const fn = Symbol(); obj[fn] = this console.log(...args); //利用解构赋值，将传入的数组解构，传入调用apply的函数中 let res = obj[fn](...args) delete obj[fn] return res } function name(age1,age2) { console.log('我是'+this.name+',我今年'+age1+'岁了'+',我明年'+age2+'岁了'); } let dog = { name: &quot;旺财&quot;, }; name._apply(dog,12,13);//我是旺财,我今年12岁了,我明年13岁了 ","link":"http://localhost:4000/post/shou-xie-javascript-de-callapply-han-shu/"},{"title":"Css选择器种类以及优先级","content":" 元素选择器 id选择器 类选择器 后代选择器 子代选择器 兄弟选择器 相邻选择器 群组选择器 全局选择器 属性选择器 伪类选择器 选择器优先级 (目录标题) 元素选择器 以标签名开头，选择所有span元素 /* 元素选择器 */ span { margin: 0; padding: 0; } id选择器 给标签取id名，以#加id名开头，具有唯一性，选择”id = ‘p1’”的元素 /* id选择器 */ #p1 { margin: 0; padding: 0; } 类选择器 给标签取class名，以点.加class名开头，选择所有该class名的元素 /* 类选择器 */ .span1 { margin: 0; padding: 0; } 后代选择器 以空格隔开包含关系的元素,查找以class=‘content’的父元素下所有的p标签（包含孙子元素 ） /* 后代选择器 */ .content p { margin: 0; padding: 0; } 子代选择器 以&gt;隔开包含关系的元素,查找以class=‘content’的父元素下所有的class=‘span1’的儿子元素 /* 子代选择器 */ .content &gt; .span1 { margin: 0; padding: 0; } 兄弟选择器 以波浪号隔开兄弟关系的元素(修饰前一个选择器往下的所有兄弟选择器) /* 兄弟选择器 */ #p1 ~ p { margin: 0; padding: 0; } 相邻选择器 以+隔开相邻关系的元素(修饰前一个选择器往下的相邻的选择器 只能一个) #p1 + .span1 { background-color: aqua; } 群组选择器 以，分隔(逗号分隔开需要修饰的选择器) /* 群组选择器 */ p, span { margin: 0; padding: 0; } 全局选择器 以*开头,查找body下所有标签 /* 全局选择器 */ * { margin: 0; padding: 0; } 属性选择器 以[ ]修饰，查找属性type=text的元素 /* 属性选择器 */ input[type=&quot;text&quot;] { background-color: aquamarine; } 伪类选择器 以：为修饰符，修饰前一个选择器，比如‘button:hover’表示当鼠标放在button元素上面时，设置字体颜色为浅蓝色 /* 伪类选择器 */ button:hover { color: aqua; } 选择器优先级 先不讨论多个选择器嵌套的情况 css优先级: !important&gt;行间样式&gt; ID选择器&gt;属性选择器&amp;&amp;伪类选择器&gt;类选择器&gt;元素选择器 具体： a:行内样式:优先级1000 b:ID选择器:优先级100 c:类选择器:优先级10 (伪类属性优先级10 ） d:元素选择器:优先级1 注意：! important:优先级最大10000 (用了后就不能修改慎用) 具体例子： span 优先级1 div span 优先级1+1 div:first-child == 1+10 .p1 span 优先级10+1. #divI span 优先级100+1 ","link":"http://localhost:4000/post/css-xuan-ze-qi-chong-lei-yi-ji-you-xian-ji/"},{"title":"关于浏览器的本地存储","content":"浏览器本地存储大小 存储内容大小一般支持5MB左右（不同浏览器可能还不一样） 存储的实现机制 浏览器通过Window.sessionStorage和Window.localStorage属性来实现本地存储机制 存储操作的相关api localStorage.setItem('key','value') //该方法接受-一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。 localStorage.getItem('key') //该方法接受一个键名作为参数，返回键名对应的值。 localStorage.removeItem('key') //该方法接受一个键名作为参数， 并把该键名从存储中删除。 localStorage.clear() //该方法会清空存储中的所有数据。 sessionStorage和localStorage的使用方法基本一致，在这里不做演示了。 一些需要注意的地方： SessionStorage存储的内容会随着浏览器窗口关闭而消失。 LocalStorage存储的内容，需要手动清除才会消失。 xxxStorage . getem(xx)如果xxx对应的value获取不到，那么geltem的返回值是null. ","link":"http://localhost:4000/post/guan-yu-liu-lan-qi-de-ben-di-cun-chu/"},{"title":"JavaScript中关于字符串的操作方法","content":"字符串的拼接：concat() 用于将一个或多个字符串拼接成一个新字符串 concat()方法可以接收任意多个参数，因此可以一次性拼接多个字符串， concat()方法不会改变原字符串 let string = 'hello' //接收一个参数 let result = string.concat(',world') //接收多个参数 let result1 = string.concat(',world',' !') console.log(string);// hello console.log(result);// hello,world console.log(result1);// hello,world ! 虽然 concat()方法可以拼接字符串，但更常用的方式是使用加号操作符（+）。而且多数情况下，对于拼接多个字符串来说，使用加号更方便。 let result = 'hello'+',world'+'!' console.log(result);//hello,world! 字符串的截取：slice(),substring(),substr() 3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，对 slice()和 substring()而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。对 substr()而言，第二个参数表示返回的子字符串数量。 任何情况下，省略第二个参数都意味着提取到字符串末尾。与 concat()方法一样，slice()、substr() 和 substring()也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。 let string = &quot;hello world&quot;; console.log(string.slice(3)); // &quot;lo world&quot; console.log(string.substring(3)); // &quot;lo world&quot; console.log(string.substr(3)); // &quot;lo world&quot; console.log(string.slice(3, 7)); // &quot;lo w&quot; console.log(string.substring(3,7)); // &quot;lo w&quot; console.log(string.substr(3, 7)); // &quot;lo worl&quot; 如果传入的参数为负值呢？ slice()方法将所有负值参数都当成字符串长度加上负参数值 substr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0 substring()方法会将所有负参数值都转换为 0 let string = &quot;hello world&quot;; console.log(string.slice(-3)); // &quot;rld&quot; console.log(string.substring(-3)); // &quot;hello world&quot; console.log(string.substr(-3)); // &quot;rld&quot; console.log(string.slice(3, -4)); // &quot;lo w&quot; console.log(string.substring(3, -4)); // &quot;hel&quot; console.log(string.substr(3, -4)); // &quot;&quot; (empty string) ","link":"http://localhost:4000/post/javascript-zhong-guan-yu-zi-fu-chuan-de-cao-zuo-fang-fa/"},{"title":"JavaScript中数组拼接的几种方式","content":"concat()方法拼接 concat方法不会更改现有数组，而是返回一个新数组。 let a = [1,2,3,4,5,6] let b = ['喵喵','旺财','大黄'] //concat let c = a.concat(b) console.log(c);//[1,2,3,4,5,6,'喵喵','旺财','大黄'] 循环拼接 let a = [1,2,3,4,5,6] let b = ['喵喵','旺财','大黄'] for(let i=0;i&lt;b.length;i++){ a.push(b[i]) } console.log(a);//[1,2,3,4,5,6,'喵喵','旺财','大黄'] push.apply()方法拼接 push.apply合并数组是把后一个数组的值依次push进前一个数组，使前一个数组发生改变 let a = [1,2,3,4,5,6] let b = ['喵喵','旺财','大黄'] a.push.apply(a,b) console.log(a);//[1,2,3,4,5,6,'喵喵','旺财','大黄'] es6结构赋值 let a = [1,2,3,4,5,6] let b = ['喵喵','旺财','大黄'] a.push(...b) console.log(a);//[1,2,3,4,5,6,'喵喵','旺财','大黄'] ","link":"http://localhost:4000/post/javascript-zhong-shu-zu-pin-jie-de-ji-chong-fang-shi/"},{"title":"Es6中关于对象方法的扩展","content":"Object.is() 这个方法与===很像，但同时也考虑到了边界情形。这个方法必须接收两个参数： 主要用于判断两个对象是否相等，但和'===有一些不一样的地方 console.log(Object.is(true, 1)); // false console.log(Object.is({}, {})); // false console.log(Object.is(&quot;2&quot;, 2)); // false // 正确的 0、-0、+0 相等/不等判定 console.log(Object.is(+0, -0)); // false console.log(Object.is(+0, 0)); // true console.log(Object.is(-0, 0)); // false // 正确的 NaN 相等判定 console.log(Object.is(NaN, NaN)); // true //要检查超过两个值，递归地利用相等性传递即可： function recursivelyCheckEqual(num, ...test) { return Object.is(num, test[0]) &amp;&amp; (test.length &lt; 2 || recursivelyCheckEqual(...test)); } Object.assign() ECMAScript 6 专门为合并对象提供了 Object.assign()方法。这个方法接收一个目标对象和一个 或多个源对象作为参数 const student={ name:'syz', age:18, aaa:'1111' } const student1={ name:'zs', age:36, bbb:'1111' } //后面的会覆盖前面的重名属性和方法 console.log(Object.assign(student,student1));//{ name: 'zs', age: 36, aaa: '1111', bbb: '1111' } 注意：后面传入的参数会覆盖前面的重名属性和方法 Object.keys() 获取对象所有的键,返回一个数组 let obj={ a:&quot;1&quot;, cities:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] } console.log(Object.keys(obj));//[ 'a', 'cities' ] Object.values() 获取对象的所有值，返回一个数组 let obj1={ a:&quot;1&quot;, cities:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] } console.log(Object.values(obj1));//[ '1', [ 'a', 'b', 'c' ] ] Object.entries() 获取对象的键和值，返回一个数组 let obj1={ a:&quot;1&quot;, cities:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] } console.log(Object.entries(obj1))//[ [ 'a', '1' ], [ 'cities', [ 'a', 'b', 'c' ] ] ] Object.setPrototypeOf() 为一个对象设置它的原型对象 const person = { dosth:&quot;play lol&quot; } const animal={ attr:['eat','drink'] } Object.setPrototypeOf(person,animal) console.log(person.__proto__.attr[0]);//eat Object.getOwnPropertyDescriptors() 获取对象的描述信息，返回一个数组 let obj1={ a:&quot;1&quot;, cities:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] } console.log(Object.getOwnPropertyDescriptors(obj1)); //输出： /* { a: { value: '1', writable: true, enumerable: true, configurable: true }, cities: { value: [ 'a', 'b', 'c' ],//值 writable: true,//该值是否可以被修改 enumerable: true,//是否可以被枚举 configurable: true,//是否可以被删除 } } */ Object.defineProperty() 创建对象的值和描述信息的函数（传一个值） const student = { name: &quot;小明&quot;, age: 19, [Symbol(&quot;level&quot;)]: &quot;优秀&quot;, }; Object.defineProperty(student, &quot;gender&quot;, { value: &quot;男&quot;, //值 writable: true, //是否可修改的 enumerable: true, //是否可以枚举的 configurable: true, //是否可以删除的 }); console.log(student)//{ name: '小明', age: 19, gender: '男', [Symbol(level)]: '优秀' } Object.defineProperties() 创建对象的值和描述信息的函数（传多个值） const student = { name: &quot;小明&quot;, age: 19, [Symbol(&quot;level&quot;)]: &quot;优秀&quot;, }; Object.defineProperties(student,{ id:{ value:'001', writable: true, //是否可修改的 enumerable: true, //是否可以枚举的 }, sex:{ value:'男', writable: true, //是否可修改的 enumerable: true, //是否可以枚举的 configurable: true, //是否可以删除的 } }) console.log(student)//{name: '小明', age: 19, id: '001', sex: '男', Symbol(level): '优秀'} 如果用上述方法创建，描述对象的属性值默认为false 确定不点个赞再走嘛？ ","link":"http://localhost:4000/post/es6-zhong-guan-yu-dui-xiang-fang-fa-de-kuo-zhan/"},{"title":"利用生成器函数解决回调地狱的问题","content":"需求：1秒后控制台输出111，然后2秒后输出222，然后三秒后输出333 原始做法 setTimeout(() =&gt; { console.log(111); setTimeout(() =&gt; { console.log(222); setTimeout(() =&gt; { console.log(333); }, 3000); }, 2000); }, 1000); 这只是三层嵌套，想象一下，如果有100层，这样的代码不仅臃肿，还不利于后期的管理 下面用生成器函数解决一下这个问题： 生成器函数做法 function one(){ setTimeout(() =&gt; { console.log(111); result.next() }, 1000); } function two(){ setTimeout(() =&gt; { console.log(222); result.next() }, 2000); } function three(){ setTimeout(() =&gt; { console.log(333); }, 3000); } function * gen(){ yield one() yield two() yield three() } let result = gen() result.next() 如果对生成器函数有不懂的小伙伴，可以看下我上一篇博客：ES6新特性：生成器函数 附上原文地址：生成器函数 ","link":"http://localhost:4000/post/li-yong-sheng-cheng-qi-han-shu-jie-jue-hui-diao-di-yu-de-wen-ti/"},{"title":"ES6新特性：生成器函数","content":"定义生成器函数 生成器函数和普通函数定义没有太大的差别，只是函数名前面多了一个* function * gen(){ console.log(111) } 执行生成器函数 生成器函数直接调用函数不会执行，需要调用生成器函数内部的next方法函数才会执行 function * gen(){ console.log(111) } let result = gen() result.next() //输出111 yield语句 yield语句会把函数分为几个部分，然后调用next函数异步去执行 function * gen(){ console.log(111) yield one() console.log(222) yield two() console.log(333) yield three() console.log(444) } let result = gen() result.next() result.next() result.next() result.next() 上诉yield语句把函数分为4个部分 第一部分为 console.log(111) yield one() 第二部分为 console.log(222) yield two() 第三部分为 console.log(333) yield three() 第四部分为 console.log(444) yield语句的返回值： 生成器函数执行之后，yield语句内的值以对象的形式返回，value中对应着yield语句中的值，done：代表着这个函数的异步任务是否走到结尾，false（没有走到结尾），true（走到了结尾） 生成器函数的传参问题 第一次调用生成器函数时的传参，为生成器的形参 下面代码中的实参AAA对应着形参args 第二个next传入的实参对应第一个yield语句的返回值 下面代码中的实参CCC对应的第一个yield语句的返回值aaa 第三个next传入的实参对应第二个yield语句的返回值 下面代码中的实参DDD对应的第一个yield语句的返回值bbb 第四个next传入的实参对应第三个yield语句的返回值 下面代码中的实参EEE对应的第一个yield语句的返回值ccc function * gen(args){ console.log(args); let aaa = yield '111' console.log(aaa); let bbb = yield '222' console.log(bbb); let ccc = yield '333' console.log(ccc); } gen函数的传参和调用问题 let result = gen('AAA') //做为前一个yield整体的返回结果 console.log(result.next()); console.log(result.next('CCC')); console.log(result.next('DDD')); console.log(result.next('EEE')); //输出结果 //AAA //{ value: '111', done: false } //CCC //{ value: '222', done: false } //DDD //{ value: '333', done: false } //EEE //{ value: undefined, done: true } 讲完啦 谢谢大家的观看 关于生成器函数的一个扩展： 利用生成器函数解决回调地狱的问题 ","link":"http://localhost:4000/post/es6-xin-te-xing-sheng-cheng-qi-han-shu/"},{"title":"Vue中如何自定义指令","content":"1.自定义指令的作用 在实际项目开发过程中，除了vue自身提供的一些固定指令，如v-if,v-show,v-model等除外，我们可能根据项目的需求来自己注册一些自定义的指令，更好的提高开发和工作效率。 2.自定义指令注册的两种方式 自定义指令有全局注册和局部注册两种方式， 3.一个自定义指令的案例（局部注册） 先看需求：定义一个v-big指令，要求和v-text功能类似，但会把绑定的数值放大10倍 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3 v-big=&quot;n&quot;&gt;{{n}}&lt;/h3&gt; &lt;button @click=&quot;n++&quot;&gt;点我n++&lt;/button&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: &quot;#app&quot;, data() { return { n: 1, }; }, //局部定义自定义指令 directives: { //自定义了一个v-big的自定义指令 big(Element, binding) { //Element为h3节点，binding.value为传入的值n Element.innerText = binding.value * 10; }, }, }); &lt;/script&gt; &lt;/body&gt; 执行结果如下： 关于上面代码的几个疑问： 1.directives是什么？ directives是vue为我们提供的一个自定义指令的对象，类似于methods，watch， 2.自定义指令名称写什么？ 我们定义的指令名称为v-big，即下面就用big来创建函数 3.big函数传入的参数是什么？ 第一个参数为当前绑定自定义指令的dom节点，第二个参数为一个对象： 我们只要关注他的value值即可，他的value值就是自定义指令传入的值n 4.big函数什么时候被调用： 当vue模板被重新解析时就会调用big函数 4.全局注册实现小案例 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3 v-big=&quot;n&quot;&gt;{{n}}&lt;/h3&gt; &lt;button @click=&quot;n++&quot;&gt;点我n++&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //全局注册了一个v-big的自定义指令 Vue.directive('big',(Element,binding)=&gt;{ Element.innerText = binding.value * 10; }) new Vue({ el: &quot;#app&quot;, data() { return { n: 1, }; }, }); &lt;/script&gt; &lt;/body&gt; 运行截图和上面一样，就不演示了。 注意全局注册为directive而不是directives，没有s。 ","link":"http://localhost:4000/post/vue-zhong-ru-he-zi-ding-yi-zhi-ling/"},{"title":"JavaScript中this的指向问题","content":" 1.直接输出的this指向window 2.全局非嵌套函数的this指向window，嵌套函数this的指向他的父级函数 3.对象的方法输出this，指向这个对象 4.dom事件方法输出this，指向dom元素 5.构造函数中this的指向： 6.箭头函数的this指向箭头函数的调用者 1.直接输出的this指向window //直接输出指向window console.log(this); //output：window 2.全局非嵌套函数的this指向window，嵌套函数this的指向他的父级函数 //全局函数输出this，指向window function fn(){ console.log(this); } fn() //output：window //嵌套函数this的指向指向他的父级函数 function F(){ this.name = '李四' function test() { console.log(this.name); } } F() //output：李四 3.对象的方法输出this，指向这个对象 //对象的方法输出this，指向这个对象 const dog={ name:'旺旺', sayName(){ console.log(this); } } dog.sayName() //output：旺旺 4.dom事件方法输出this，指向dom元素 //html: &lt;button id=&quot;btn&quot;&gt;点我触发方法&lt;/button&gt; //js: //dom事件方法输出this，指向dom元素 document.querySelector(&quot;#btn&quot;).onclick = function click() { console.log(this); } //output:&lt;button id=&quot;btn&quot;&gt;点我触发方法&lt;/button&gt; 5.构造函数中this的指向： 如果把构造函数当成普通函数去执行的话，this还是指向window function F(){ this.name = '李四' console.log(this); } F() //output:window 如果用构造函数创建了一个对象，会改变其中this的指向：this会指向构造函数的原型对象 function F(){ this.name = '李四' console.log(this); } let f = new F() //output：F {name: '李四'} 在讲箭头函数的this指向之前，先看一个转换this指向的小例子 const dog1={ name:'旺旺', sayName(){ //sayName函数的this指向对象dogs的this，我们可以用_this做一个中转变量， _this = this setTimeout(function () { //这里的_this就是对象dogs的this console.log(_this.name); },1000) } } dog1.sayName() //output：一秒之后会输出：旺旺 6.箭头函数的this指向箭头函数的调用者 我们上面的小例子还可以用箭头函数的方式解决this的指向问题 const dog2={ name:'旺旺', sayName(){ setTimeout(() =&gt; { console.log(this.name); }, 2000); } } dog2.sayName() //output：一秒之后会输出：旺旺 因为箭头函数的this指向箭头函数的调用者：（sayName函数），因为sayName函数的this指向为对象dog2，所以箭头函数的this指向为对象dog2，所以上面函数一秒之后会输出：旺旺 谢谢大家的观看，如果有所收获请点个赞吧（拜谢，拜谢，拜谢） ","link":"http://localhost:4000/post/javascript-zhong-this-de-zhi-xiang-wen-ti/"},{"title":"Es6新特性：关于Promise的保姆级教程","content":" 1.Promise是什么？ 2.Promise的三种状态 3.创建Promise对象 4.执行promise的回调函数 6.Promise对象的作用是什么？ 7.扩展：利用promise封装AJAX函数 1.Promise是什么？ Promise是最早由社区提出和实现的一种解决异步编程的方案，比其他传统的解决方案（回调函数和事件）更合理和更强大。 ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 2.Promise的三种状态 1.初始化状态：pending（进行中） 2.当调用resolve时，状态由pending变为fulfilled（成功） 3.当调用reject时，状态由pending变为rejected（失败） 可能有的小伙伴这里看的比较懵，下面会用代码来给大家展示 3.创建Promise对象 这里的话我们就是用const声明了一个promise函数 promise对象可以有两个参数，resolve，reject，这两个参数执行之后，分别为把promise对象的状态改变为成功和失败 const p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&quot;成功了&quot;); // reject('失败了') }, 2000); }); 我们这里用定时器来模拟数据的发送 重点：这里如果运行函数的话我们会发现不会输出任何结果！为什么呢？ 原因的话是promise对象后要跟一个回调函数，我们看接下来的代码： 4.执行promise的回调函数 const p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&quot;成功了&quot;); // reject('失败了') }, 2000); }); p.then( (data) =&gt; { console.log(data); }, (reson) =&gt; {console.error(reson)} ); //output：2秒之后输出‘成功了‘ 这里在上一版函数的基础上加了一个回调函数，这里的回调函数可以跟两个函数，一个是状态为成功时候的返回值（在上文中我们用data来传递参数），一个是状态为失败之后的返回值（我们用reson表示） 重点：因为上方我们创建promise对象的时候，我们用resolve将promise对象的状态由pending变为fulfilled（成功）了，所以下方回调函数为执行传参为data的回调函数，输出成功了。 如果是把promise对象的状态改为reject，下方回调函数会执行传参为reson的回调函数，输出失败了 如下代码： const p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // resolve(&quot;成功了&quot;); reject('失败了') }, 2000); }); p.then( (data) =&gt; { console.log(data); }, (reson) =&gt; {console.error(reson)} ); //output：2秒之后输出‘失败了‘ promise对象的回调函数里面还可以返回promise类型的对象 6.Promise对象的作用是什么？ 因为回调函数里面还可以返回promise类型的对象，所以promise对象常常被用来解决回调地狱的问题 什么是回调地狱问题呢?我们来看下面的代码： setTimeout(() =&gt; { console.log(&quot;客户登录&quot;); setTimeout(() =&gt; { console.log(&quot;选购产品&quot;); setTimeout(() =&gt; { console.log(&quot;体验产品&quot;); }, 3000); }, 2000); }, 1000); 上诉函数就是一个最简单的回调问题：首先要获得客户登录的数据，然后根据客户登录的账号给客户推荐合适商品，然后跟据客户选购的商品数据，给客户免费体验相应的商品 这只是三层嵌套，如果是100层呢？这样的代码不仅不利于日后的维护，而且还显得很臃肿 下面我们用promise对象的方式来解决这样类型的问题 代码如下： const p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&quot;客户登录&quot;); // reject('失败了') }, 1000); }); p.then( (data1)=&gt;{ return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { //返回data1和‘客户选购’组成的数组，这里的data1为上面promise对象resolve的‘客户登录’ resolve([data1,'客户选购']); // reject('失败了') }, 2000); }); } ).then( (data2)=&gt;{ return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { //data2=[ '客户登录', '客户选购' ] //这里的data2为上面promise对象resolve的data1和‘客户选购’组成的数组 data2.push('体验产品') resolve(data2); // reject('失败了') }, 2000); }); } ).then( (data)=&gt;{ //此时data为[ '客户登录', '客户选购', '体验产品' ] console.log(data); } ) //output:最后输出的结果为[ '客户登录', '客户选购', '体验产品' ] -这样就解决了回调地狱的问题 7.扩展：利用promise封装AJAX函数 这里就不多bb了，直接上代码： const p = new Promise((resolve, reject) =&gt; { //创建对象 const xhr = new XMLHttpRequest(); //初始化 xhr.open(&quot;GET&quot;, &quot;https://api.uixsj.cn/hitokoto/get?type=social&quot;); //发送请求 xhr.send(); //绑定事件，处理响应结果 xhr.onreadystatechange = () =&gt; { if (xhr.readyState === 4) { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { resolve(xhr.response) } else { reject(xhr.status) } } }; }); p.then( (data)=&gt;{ console.log(data); }, (reson)=&gt;{ console.log(reason); } ) 小小萌新，瑟瑟发抖，还请各位大佬多多指教（拜谢拜谢拜谢） ","link":"http://localhost:4000/post/es6-xin-te-xing-guan-yu-promise-de-bao-mu-ji-jiao-cheng/"},{"title":"Es6新特性：set","content":"1.set的一些重要的特性 (1)Set.prototype.constructor，构造函数，默认是set函数 (2)Set.prototype.size,返回set实例的成员总数 (3)set是一种数据结构，是伪数组，无法访问长度，可以Array.from方法可以将set结构转化数组，再访问它的长度； (4)set里面的原始值不允许重复，let set = new Set([1,2,3,1,2,3])，此时set为[1,2,3] (5)set里面添加的对象即使相同也是不相等的，例如：set.add({a:1}); set.add({a:1}); 可以同时存在； 2.set的四种操作方法： // 添加元素 add(value),用于向数组中添加元素，返回set结构本身； set.add(11112); //删除元素 delete(value),删除元素，返回一个bool值，表示是否删除成功； set.delete(23); //是否存在某个元素 has(value),返回一个bool值表示set中是否含有本元素； set.has(13); console.log(set.has(13)); //清除所有成员 clear(),清除所有的set成员，没有返回值； set.clear(); console.log(set); 3.set的遍历方法 Set 会维护值插入时的顺序，因此支持按顺序迭代。 集合实例可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 values()方 法及其别名方法 keys()（或者 Symbol.iterator 属性，它引用 values()）取得这个迭代器： console.log(set1.keys==set1[Symbol.iterator]);//true console.log(set1.values==set1[Symbol.iterator]);//true //1. let set1 = new Set(['喵喵','旺旺','啾啾']); for(let key of set1.keys()){ console.log(key); } //output: //喵喵 //旺旺 //啾啾 //2. for(let value of set1.values()){ console.log(value); } //output: //喵喵 //旺旺 //啾啾 //3. for (let value of set1[Symbol.iterator]()) { console.log(value); } //output: //喵喵 //旺旺 //啾啾 //4. for(let item of set1.entries()){ console.log(item); } //output: //[ '喵喵', '喵喵' ] //[ '旺旺', '旺旺' ] //[ '啾啾', '啾啾' ] //5. let myArr = new Set([1,2,3,4,5]); for(let x of myArr){ console.log(x); } //output: //1 //2 //3 //4 //5 ","link":"http://localhost:4000/post/es6-xin-te-xing-set/"},{"title":"正则表达式的用途","content":"0.判断特定字符串 要检验某一字符串是否符合特定的格式，最方便的方式就是正则表达式: &lt;!-- 判断变量是否符合命名规则，v是要进行判断的变量名 --&gt; const value = /[a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*/; value.test(v) - test &gt;&gt;&gt; var value=/[a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*/; &gt;&gt;&gt; value.test('v') // true 1.切割字符串 在读取用户的输入的多个数据时，数据间的分隔符可能是多种多样的，有的人用一个空格，有个人用多个空格，有个人用逗号顿号分号等，而我们读取的是一整个的字符串，如何把这个字符串拆分为一个一个的数据项呢，此时正则就可以上场了 const reg=/[\\s\\,\\、\\。\\,]+/ const data=dataInput.split(reg) - test &gt;&gt;&gt; var reeg=/[\\s\\,\\、\\。\\,]+/ &gt;&gt;&gt; dataInput= &quot;A man, a plan, a canal: Panama&quot; // A man, a plan, a canal: Panama' &gt;&gt;&gt; dataInput.split(reeg) // ['A', 'man', 'a', 'plan', 'a', 'canal:', 'Panama'] 这样写，程序的容错性就会明显提升很多 2.提取字符串信息 使用exec方法最终得到的是一个数组，里面存放字符串中与正则表达式中匹配的内容，我们可以通过这种方法便捷的提取字符串中的内容 const re = /^(\\d+)(0*)$/; re.exec('12300') const reg = /^(\\d+?)(0*)$/; reg.exec('12300') - test &gt;&gt;&gt; const re = /^(\\d+)(0*)$/; &gt;&gt;&gt; re.exec('12300') // ['12300', '12300', '', index: 0, input: '12300', groups: undefined] &gt;&gt;&gt; const reg = /^(\\d+?)(0*)$/; &gt;&gt;&gt; reg.exec('12300') // ['12300', '123', '00', index: 0, input: '12300', groups: undefined] 3.替换字符串 使用string对象的replace方法可以对字符串中的某一部分进行替换，使用正则字符串后，可以方便的选择字符串中的特定字符，如显示客户信息时要将字符串中的金额数字替换为&quot;*&quot; str.replace(/\\d+/,&quot;*&quot;); - test &gt;&gt;&gt;str = &quot;$1&quot; // '$1' &gt;&gt;&gt;str.replace(/\\d+/g,&quot;*&quot;) // '$*' ","link":"http://localhost:4000/post/zheng-ze-biao-da-shi-de-yong-tu/"},{"title":"HTML语法","content":" 标签和属性不区分大小写，推荐小写 空标签可以不闭合，比如input，meta 属性值推荐用双引号包裹 某些属性值可以省略，比如required，readonly ","link":"http://localhost:4000/post/html-yu-fa/"},{"title":"前端是什么？","content":"1.解决GUI（图形界面下的）人机问题 2.跨终端 - pc/移动浏览器 - 客户端/小程序 - VR/AR等 3.Web技术栈 🚩前端工程师是使用Web技术栈解决多端图形用户界面交互问题的工程师。 ","link":"http://localhost:4000/post/qian-duan-shi-shi-me/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"http://localhost:4000/post/hello-gridea/"}]}